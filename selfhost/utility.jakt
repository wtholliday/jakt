// Copyright (c) 2022, JT <jt@serenityos.org>
// Copyright (c) 2022, Andreas Kling <kling@serenityos.org>
//
// SPDX-License-Identifier: BSD-2-Clause

function panic(anon message: String) -> never {
    eprintln("internal error: {}", message)
    abort()
}

function todo(anon message: String) {
    eprintln("TODO: {}", message)
    abort()
}

function join(anon strings: [String], separator: String) -> String {
    mut output = ""
    
    mut i = 0uz
    for s in strings.iterator() {
        output += s
        if i < strings.size() - 1 {
            output += separator
        }
        i++
    }

    return output
}

function prepend_to_each(anon strings: [String], prefix: String) throws -> [String] {
    mut output: [String] = []
    for str in strings.iterator() {
        output.push(prefix + str)
    }
    return output
}

function append_to_each(anon strings: [String], suffix: String) throws -> [String] {
    mut output: [String] = []
    for str in strings.iterator() {
        output.push(str + suffix)
    }
    return output
}

struct Span {
    file_id: FileId
    start: usize
    end: usize

    function contains(this, span: Span) -> bool {
        return .file_id.equals(span.file_id) and span.start >= .start and span.end <= .end
    }

    function is_in_offset_range(this, start: usize, end: usize) => start <= .start and end >= .end
}

struct FileId {
    id: usize

    function equals(this, anon rhs: FileId) -> bool {
        return .id == rhs.id
    }
}

function extend_array<T>(mut target: [T], extend_with: [T]) throws {
    target.add_capacity(extend_with.size())
    for v in extend_with.iterator() {
        target.push(v)
    }
}

// FIXME: Use jakt stdlib if available
struct ArgsParser {
    args: [String]
    removed_indices: [usize]
    definitely_positional_args: [String]

    function flag(mut this, anon names: [String]) throws -> bool {
        for i in 0...args.size() {
            for name in names.iterator() {
                if .args[i] == name {
                    .removed_indices.push(i)
                    return true
                }
            }
        }

        return false
    }

    function option(mut this, anon names: [String]) throws -> String? {
        for i in 1...args.size() {
            for name in names.iterator() {
                if .args[i] == name {
                    if .args.size() <= i+1 {
                        eprintln("The option '{}' requires a value, but none was supplied", name)
                        throw Error::from_errno(200)
                    }

                    .removed_indices.push(i)
                    .removed_indices.push(i+1)

                    return .args[i+1]
                }
                if .args[i].starts_with(name) {
                    .removed_indices.push(i)
                    return .args[i].substring(start: name.length(), length: .args[i].length() - name.length())
                }
            }
        }

        return None
    }

    function option_multiple(mut this, anon names: [String]) throws -> [String]
    {
        mut result: [String] = []
        for i in 1...args.size() {
            for name in names.iterator() {
                if .args[i] == name {
                    if .args.size() <= i + 1 {
                        eprintln("The option '{}' requires a value, but none was supplied", name)
                        throw Error::from_errno(200)
                    }

                    .removed_indices.push(i)
                    .removed_indices.push(i + 1)
                    result.push(.args[i + 1])
                    continue
                }
                if .args[i].starts_with(name) {
                    .removed_indices.push(i)
                    result.push(.args[i].substring(start: name.length(), length: .args[i].length() - name.length()))
                }
            }
        }
        return result
    }

    function from_args(anon args: [String]) throws -> ArgsParser {
        mut parser = ArgsParser(args, removed_indices: [], definitely_positional_args: [])
        mut i = 0uz
        for arg in parser.args.iterator() {
            if arg == "--" {
                parser.definitely_positional_args = parser.args[(i+1)..parser.args.size()].to_array()
                parser.args = parser.args[0..i].to_array()
                break
            }
            i += 1
        }

        return parser
    }

    function remaining_arguments(this) throws -> [String] {
        mut remaining : [String] = []

        for i in 0...args.size() {
            if not .removed_indices.contains(i) {
                remaining.push(.args[i])
            }
        }

        for arg in .definitely_positional_args.iterator() {
            remaining.push(arg)
        }

        return remaining
    }

}

function escape_for_quotes(anon s: String) throws -> String {
    mut builder = StringBuilder::create()
    for i in 0..s.length() {
        let c = s.byte_at(i)
        match c {
            b'"' =>  { builder.append_string("\\\"") }
            b'\\' => { builder.append_string("\\\\") }
            b'\n' => { builder.append_string("\\n") }
            else =>  { builder.append(c) }
        }
    }

    return builder.to_string()
}

function interpret_escapes(anon s: String) throws -> String {
    mut builder = StringBuilder::create()
    mut in_escape = false
    for i in 0..s.length() {
        let c = s.byte_at(i)
        match c {
            b'\\' => {
                if in_escape {
                    builder.append(b'\\')
                    in_escape = false
                } else {
                    in_escape = true
                }
            }
            b'"' | b'\'' => {
                if in_escape {
                    builder.append(c)
                    in_escape = false
                }
            }
            b'n' => {
                if in_escape {
                    builder.append(b'\n')
                    in_escape = false
                } else {
                    builder.append(c)
                }
            }
            else => {
                builder.append(c)
                in_escape = false
            }
        }
    }

    return builder.to_string()
}

function null<T>() -> raw T {
    unsafe {
        cpp {
            "return nullptr;"
        }
    }

    abort()
}

function allocate<T>(count: usize) -> raw T {
    unsafe {
        cpp {
            "return static_cast<T*>(malloc(count * sizeof(T)));"
        }
    }

    abort()
}

function is_ascii_alpha(anon c: u8) => (c >= b'a' and c <= b'z') or (c >= b'A' and c <= b'Z')
function is_ascii_digit(anon c: u8) => (c >= b'0' and c <= b'9')
function is_ascii_hexdigit(anon c: u8) => (c >= b'0' and c <= b'9') or (c >= b'a' and c <= b'f') or (c >= b'A' and c <= b'F')
function is_ascii_octdigit(anon c: u8) => (c >= b'0' and c <= b'7')
function is_ascii_binary(anon c: u8) => (c == b'0' or c == b'1')
function is_ascii_alphanumeric(anon c: u8) -> bool => is_ascii_alpha(c) or is_ascii_digit(c)

function is_whitespace(anon byte: u8) => byte == b' ' or byte == b'\t' or byte == b'\r'

function _rotate_left(anon x: u32, anon n: u32) => (((x) << (n)) | ((x) >> (32 - (n))))
function _F(anon x: u32, anon y: u32, anon z: u32) => (((x) & (y)) | (~(x) & (z)))
function _FF(anon a: u32, anon b: u32, anon c: u32, anon d: u32, anon k: u32, anon s: u32, anon Ti: u32, anon X: [u32]) -> u32 {
    let t = a + _F(b,c,d) + X[k] + Ti
    return _rotate_left(t, s) + b
}
function _G(anon x: u32, anon y: u32, anon z: u32) => (((x) & (z)) | ((y) & ~(z)))
function _GG(anon a: u32, anon b: u32, anon c: u32, anon d: u32, anon k: u32, anon s: u32, anon Ti: u32, anon X: [u32]) -> u32 {
    let t = a + _G(b,c,d) + X[k] + Ti
    return _rotate_left(t, s) + b
}
function _H(anon x: u32, anon y: u32, anon z: u32) => ((x) ^ (y) ^ (z))
function _HH(anon a: u32, anon b: u32, anon c: u32, anon d: u32, anon k: u32, anon s: u32, anon Ti: u32, anon X: [u32]) -> u32 {
    let t = a + _H(b,c,d) + X[k] + Ti
    return _rotate_left(t, s) + b
}
function _I(anon x: u32, anon y: u32, anon z: u32) => ((y) ^ ((x) | ~(z)))
function _II(anon a: u32, anon b: u32, anon c: u32, anon d: u32, anon k: u32, anon s: u32, anon Ti: u32, anon X: [u32]) -> u32 {
    let t = a + _I(b,c,d) + X[k] + Ti
    return _rotate_left(t, s) + b
}

struct MD5State {

    a: u32
    b: u32
    c: u32
    d: u32

    function process(this, X: [u32]) -> MD5State {

        let T1  : u32 = 0xd76aa478
        let T2  : u32 = 0xe8c7b756
        let T3  : u32 = 0x242070db
        let T4  : u32 = 0xc1bdceee
        let T5  : u32 = 0xf57c0faf
        let T6  : u32 = 0x4787c62a
        let T7  : u32 = 0xa8304613
        let T8  : u32 = 0xfd469501
        let T9  : u32 = 0x698098d8
        let T10 : u32 = 0x8b44f7af
        let T11 : u32 = 0xffff5bb1
        let T12 : u32 = 0x895cd7be
        let T13 : u32 = 0x6b901122
        let T14 : u32 = 0xfd987193
        let T15 : u32 = 0xa679438e
        let T16 : u32 = 0x49b40821
        let T17 : u32 = 0xf61e2562
        let T18 : u32 = 0xc040b340
        let T19 : u32 = 0x265e5a51
        let T20 : u32 = 0xe9b6c7aa
        let T21 : u32 = 0xd62f105d
        let T22 : u32 = 0x02441453
        let T23 : u32 = 0xd8a1e681
        let T24 : u32 = 0xe7d3fbc8
        let T25 : u32 = 0x21e1cde6
        let T26 : u32 = 0xc33707d6
        let T27 : u32 = 0xf4d50d87
        let T28 : u32 = 0x455a14ed
        let T29 : u32 = 0xa9e3e905
        let T30 : u32 = 0xfcefa3f8
        let T31 : u32 = 0x676f02d9
        let T32 : u32 = 0x8d2a4c8a
        let T33 : u32 = 0xfffa3942
        let T34 : u32 = 0x8771f681
        let T35 : u32 = 0x6d9d6122
        let T36 : u32 = 0xfde5380c
        let T37 : u32 = 0xa4beea44
        let T38 : u32 = 0x4bdecfa9
        let T39 : u32 = 0xf6bb4b60
        let T40 : u32 = 0xbebfbc70
        let T41 : u32 = 0x289b7ec6
        let T42 : u32 = 0xeaa127fa
        let T43 : u32 = 0xd4ef3085
        let T44 : u32 = 0x04881d05
        let T45 : u32 = 0xd9d4d039
        let T46 : u32 = 0xe6db99e5
        let T47 : u32 = 0x1fa27cf8
        let T48 : u32 = 0xc4ac5665
        let T49 : u32 = 0xf4292244
        let T50 : u32 = 0x432aff97
        let T51 : u32 = 0xab9423a7
        let T52 : u32 = 0xfc93a039
        let T53 : u32 = 0x655b59c3
        let T54 : u32 = 0x8f0ccc92
        let T55 : u32 = 0xffeff47d
        let T56 : u32 = 0x85845dd1
        let T57 : u32 = 0x6fa87e4f
        let T58 : u32 = 0xfe2ce6e0
        let T59 : u32 = 0xa3014314
        let T60 : u32 = 0x4e0811a1
        let T61 : u32 = 0xf7537e82
        let T62 : u32 = 0xbd3af235
        let T63 : u32 = 0x2ad7d2bb
        let T64 : u32 = 0xeb86d391

        mut a = this.a
        mut b = this.b
        mut c = this.c
        mut d = this.d

        a = _FF(a, b, c, d,  0,  7,  T1, X)
        d = _FF(d, a, b, c,  1, 12,  T2, X)
        c = _FF(c, d, a, b,  2, 17,  T3, X)
        b = _FF(b, c, d, a,  3, 22,  T4, X)
        a = _FF(a, b, c, d,  4,  7,  T5, X)
        d = _FF(d, a, b, c,  5, 12,  T6, X)
        c = _FF(c, d, a, b,  6, 17,  T7, X)
        b = _FF(b, c, d, a,  7, 22,  T8, X)
        a = _FF(a, b, c, d,  8,  7,  T9, X)
        d = _FF(d, a, b, c,  9, 12, T10, X)
        c = _FF(c, d, a, b, 10, 17, T11, X)
        b = _FF(b, c, d, a, 11, 22, T12, X)
        a = _FF(a, b, c, d, 12,  7, T13, X)
        d = _FF(d, a, b, c, 13, 12, T14, X)
        c = _FF(c, d, a, b, 14, 17, T15, X)
        b = _FF(b, c, d, a, 15, 22, T16, X)

        a = _GG(a, b, c, d,  1,  5, T17, X)
        d = _GG(d, a, b, c,  6,  9, T18, X)
        c = _GG(c, d, a, b, 11, 14, T19, X)
        b = _GG(b, c, d, a,  0, 20, T20, X)
        a = _GG(a, b, c, d,  5,  5, T21, X)
        d = _GG(d, a, b, c, 10,  9, T22, X)
        c = _GG(c, d, a, b, 15, 14, T23, X)
        b = _GG(b, c, d, a,  4, 20, T24, X)
        a = _GG(a, b, c, d,  9,  5, T25, X)
        d = _GG(d, a, b, c, 14,  9, T26, X)
        c = _GG(c, d, a, b,  3, 14, T27, X)
        b = _GG(b, c, d, a,  8, 20, T28, X)
        a = _GG(a, b, c, d, 13,  5, T29, X)
        d = _GG(d, a, b, c,  2,  9, T30, X)
        c = _GG(c, d, a, b,  7, 14, T31, X)
        b = _GG(b, c, d, a, 12, 20, T32, X)

        a = _HH(a, b, c, d,  5,  4, T33, X)
        d = _HH(d, a, b, c,  8, 11, T34, X)
        c = _HH(c, d, a, b, 11, 16, T35, X)
        b = _HH(b, c, d, a, 14, 23, T36, X)
        a = _HH(a, b, c, d,  1,  4, T37, X)
        d = _HH(d, a, b, c,  4, 11, T38, X)
        c = _HH(c, d, a, b,  7, 16, T39, X)
        b = _HH(b, c, d, a, 10, 23, T40, X)
        a = _HH(a, b, c, d, 13,  4, T41, X)
        d = _HH(d, a, b, c,  0, 11, T42, X)
        c = _HH(c, d, a, b,  3, 16, T43, X)
        b = _HH(b, c, d, a,  6, 23, T44, X)
        a = _HH(a, b, c, d,  9,  4, T45, X)
        d = _HH(d, a, b, c, 12, 11, T46, X)
        c = _HH(c, d, a, b, 15, 16, T47, X)
        b = _HH(b, c, d, a,  2, 23, T48, X)

        a = _II(a, b, c, d,  0,  6, T49, X)
        d = _II(d, a, b, c,  7, 10, T50, X)
        c = _II(c, d, a, b, 14, 15, T51, X)
        b = _II(b, c, d, a,  5, 21, T52, X)
        a = _II(a, b, c, d, 12,  6, T53, X)
        d = _II(d, a, b, c,  3, 10, T54, X)
        c = _II(c, d, a, b, 10, 15, T55, X)
        b = _II(b, c, d, a,  1, 21, T56, X)
        a = _II(a, b, c, d,  8,  6, T57, X)
        d = _II(d, a, b, c, 15, 10, T58, X)
        c = _II(c, d, a, b,  6, 15, T59, X)
        b = _II(b, c, d, a, 13, 21, T60, X)
        a = _II(a, b, c, d,  4,  6, T61, X)
        d = _II(d, a, b, c, 11, 10, T62, X)
        c = _II(c, d, a, b,  2, 15, T63, X)
        b = _II(b, c, d, a,  9, 21, T64, X)

        return MD5State(
            a: this.a + a,
            b: this.b + b,
            c: this.c + c,
            d: this.d + d
        )
    }
}